################################
# 提出プログラムREADMEファイル
#
# Theme : Sequent Calculusによる
#         証明木の作成プログラム
# Author: Yuki Yamaguchi
# Date  : 2022/01/13
################################


目次：
  １．Sequent Calculus
  ２．プログラム仕様
  ３．実行結果




１．Sequent Calculus
  Sequent Calculusは命題論理や一階述語論理の証明で用いられる演繹手法である。
  Sequent CalculusにはLKやLJ、LDなどいくつかの種類があるが、ここではLKによる命題論理の証明を取り扱う。

定義(命題)：
  命題とは、以下に示す(1),(2)である。
  (1)：原子命題A,B,C,...は命題である。
  (2)：命題φ,χについて、
       ¬φ, φ∧χ, φ∨χ, φ⇒χ
       は命題である。


定義(Sequent)：
  Sequentとは、記号ー＞で結合された有限個の命題列の対である。
  左辺が仮定、右辺が結論と呼ばれる。
  　Sequentの例：
  　　・Aー＞A
  　　・Γー＞A,⊿
  　　・ー＞A∨¬A
  （直観的な意味としては、
  　A1,A2,...,An ー＞ B1,B2,...,Bm
    (A1∧A2∧...∧An) ー＞ (B1∧B2∧...∧Bm)
  となる）

記法：
  A,B：命題論理の命題を表す記号
  Γ,⊿,Σ,Π：有限個の命題の集合
  ¬,∧,∨,⇒：論理結合子(否定,かつ,または,ならば)
  ー＞：Sequentの左右の命題列をつなぐ記号

定義(証明木)：
  証明木とは、次の(1),(2)のいずれかである。
  (1)initial Sequent Aー＞A
  (2)P1 P2                 S1 S2
     -- -- が証明木であり、----- がLK Rulesであるとき、
     S1 S2                   S

     P1 P2
     -- --
     S1 S2 は証明木である。このSをend Sequentという
     -----
       S

定義(証明可能)：
  Sequent Sが証明可能であるとは、Sがある証明木のend Sequentであることである。

定義(LK Rules)：
  以下をStructual Rulesという。

    Γー＞⊿                    Γー＞⊿
  -----------(weakening L)      ----------(weakening R)
  A,Γー＞⊿                    Γー＞⊿,A

  A,A,Γー＞⊿                  Γー＞⊿,A,A
  ------------(contraction L)   ------------(contraction R)
    A,Γー＞⊿                  Γー＞⊿,A

  Γ,A,B,Πー＞⊿               Γー＞⊿,A,B,Σ
  ---------------(exchange L)   --------------(exchange R)
  Γ,B,A,Πー＞⊿               Γー＞⊿,B,A,Σ

                 Γー＞⊿,A     A,Πー＞Σ
                 -------------------------(cut)
                        Γ,Πー＞⊿,Σ

  以下をLogical connective Rulesという。

     A,Γー＞⊿           B,Γー＞⊿         Γー＞⊿,A     Γー＞⊿,B
  -------------(∧L1)  -------------(∧L2)   -------------------------(∧R)
  A∧B,Γー＞⊿        A∧B,Γー＞⊿                Γー＞⊿,A∧B

  A,Γー＞⊿     B,Γー＞⊿                     A,Γー＞⊿           B,Γー＞⊿
  -------------------------(∨L)             -------------(∨R1)  -------------(∨R2)
         A∨B,Γー＞⊿                       A∨B,Γー＞⊿        A∨B,Γー＞⊿

  Γー＞⊿,A     B,Πー＞Σ                  A,Γー＞⊿,B
  -------------------------(⇒L)             ---------------(⇒R)
     A⇒B,Γ,Πー＞⊿, Σ                      Γー＞⊿,A⇒B

      Γー＞⊿,A                             A,Γー＞⊿
  --------------(￢L)                        --------------(￢R)
  ￢A,Γー＞⊿                                 Γー＞⊿,￢A


定理(Cut-elimination)：
  任意のLKの命題論理のSequent Sについて、SがLKで証明可能であれば、
  証明木にcut Ruleを含まない証明木でも証明可能である。

定義(Decomposition Rules)：
  プログラムで各Ruleを実装するにあたり、Structual Rulesからcutを除いたRulesと、
  Logical connective Rulesを統合する。
  これにより、各Ruleの適用によって論理結合子が1つ増加するため、再帰的に証明が可能となる。

   Γ',A,B,Γー＞⊿                                 Γー＞⊿',A,⊿     Γー＞⊿',B,⊿
  -----------------(∧L)                           ----------------------------------(∧R)
  Γ',A∧B,Γー＞⊿                                          Γー＞⊿',A∧B,⊿

  Γ',A,Γー＞⊿     Γ',B,Γー＞⊿                  Γ',A,B,Γー＞⊿
  ---------------------------------(∨L)           ------------------(∨R2)
           Γ',A∨B,Γー＞⊿                        Γ',A∨B,Γー＞⊿

  Γ',Γー＞⊿',A,⊿     Γ',B,Γー＞ ⊿',⊿        Γ',A,Γー＞⊿',B,⊿
  ------------------------------------------(⇒L)  ---------------------(⇒R)
              Γ',A⇒B,Γー＞⊿', ⊿               Γ',Γー＞⊿',A⇒B,⊿

      Γ',Γー＞⊿',A,⊿                           Γ',A,Γー＞⊿',⊿
  ----------------------(￢L)                      ----------------------(￢R)
  Γ',￢A,Γー＞⊿',⊿                               Γ',Γー＞⊿',￢A,⊿




２．プログラム仕様
本プログラムは、証明したい命題をLKの命題論理のSequentでプログラムに入力し、
命題が証明可能であればその証明木を示し、そうでなければ証明不可能と示す。

プログラムはPython3.8.10を用いて作成した。
特別なライブラリは用いておらず、Python3.8特有の機能も用いていないため、
Python3系統であれば動作する。

以下にファイル構成を示す。

/
|-README.txt
|-main.py
|-proposition.py
|-sequentProver.py

main.pyには証明したい命題をSequentによって表現し、print-proof関数により証明木を出力する。
命題はproposition.pyで定義した命題データ構造を用いて表現し、
SequentはsequentProver.pyで定義したSequentデータ構造を用いて表現する。
例：排中律(A∨¬A)
　　SEQUENT([], [OR(ATOM(A), NEG(ATOM(A)))])


proposition.pyには、上記に示した命題の定義を表すデータ構造をクラスを用いて定義した。
各クラスATOM,NEG,AND,OR,IMPLはPROPOSITIONクラスを継承して定義した。
・原子命題ATOMについて
　ここではATOMオブジェクト生成時に入力される変数は文字列のみ扱っているが、
　それ以外の型でも等価であるかを判定できれば入力しても良い。
・その他の論理結合子を含む命題について
　命題オブジェクト生成時に入力される変数はPROPOSITIONオブジェクトである必要がある。
　また、文字列変換する際の表示のされかたを__str__で定義することができる。


sequentProver.pyでは、Sequentデータ構造の定義と、証明関数、証明木の表示関数を定義した。
・Sequent メンバ：
　ls：左辺の命題のリスト
　ls_atom：左辺の原子命題のリスト
　ls_lc：左辺の論理結合子(logical connective)を含む命題のリスト
　rs,rs_atom,rs_lc：右辺についてのメンバ
・Sequent メソッド：
　is_atomic：Sequentの左右の命題列が全て原子命題かを判定する述語
　is_initial：Sequentの左右の命題列に等価な原子命題が存在するか判定する述語
　get_upper_sequent：適用できるDecomposition Rulesの変形規則が存在するとき、
　　　　　　　　　　 変形規則の上段のSequentと変形規則を表す文字列をタプルで返す関数

is_provable(seq)：Sequent seqが証明可能かを判定する述語
print_proof_figure(seq)：Sequent seqが証明可能でなければNot Provableを表示し、
　　　　　　　　　　　　 証明可能ならばその証明木を表示する関数




３．実行結果
main.pyを実行した結果を以下に示した。
各Testの意味は以下の通りである。

Test1： 排中律
Test2： A⇒Bと¬A∨Bは論理的等価
Test3： 証明可能でない例
Test4： Test3と似ている証明可能な例
Test5： 三段論法

実行結果から、プログラムは正しく動作していることが確認された。

----------------- 実行結果 -----------------

Test 1:   ==> ( A  v - A )
Proof Figure 1:
 A  ==>  A
-----------
  ==>  A ,- A  [-R]
-------------------
  ==> ( A  v - A ) [vR]

Test 2: ( A  ->  B ) ==> (- A  v  B )
Proof Figure 2:
 A  ==>  A , B   B , A  ==>  B
--------------- ---------------
  ==>  A , B ,- A  [-R]  B  ==>  B ,- A  [-R]
----------------------- ---------------------
  ==>  A ,(- A  v  B ) [vR]  B  ==> (- A  v  B ) [vR]
--------------------------- -------------------------
( A  ->  B ) ==> (- A  v  B ) [->L]

Test 3:   ==> (( A  ->  B ) ->  A )
Proof Figure 3:
Not Provable.

Test 4:   ==> ( A  -> ( B  ->  A ))
Proof Figure 4:
 A , B  ==>  A
---------------
 A  ==> ( B  ->  A ) [->R]
--------------------------
  ==> ( A  -> ( B  ->  A )) [->R]

Test 5:  A ,( A  ->  B ),( B  ->  C ) ==>  C
Proof Figure 5:
 A  ==>  C , A , B   A , C  ==>  C , A   A , B  ==>  C , B   A , B , C  ==>  C
------------------- ------------------- ------------------- -------------------
 A ,( B  ->  C ) ==>  C , A  [->L]  A , B ,( B  ->  C ) ==>  C  [->L]
---------------------------------- ----------------------------------
 A ,( A  ->  B ),( B  ->  C ) ==>  C  [->L]

